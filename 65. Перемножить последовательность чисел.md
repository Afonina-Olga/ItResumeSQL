# Перемножить последовательность чисел

## Дано
Дана таблица ```Numbers```, которая представляет из себя последовательность чисел:

```
+-----+
|  a  |
+-----+
|  1  |
|  2  |
|  3  |
|  4  |
|  6  |
|  7  |
|  10 |
|  11 |
|  12 |
|  13 |
|  15 |
|  17 |
+-----+
```

## Задание
Задача состоит в том, чтобы перемножить все значения между собой.

## Столбцы в результате
```multiplier``` - рассчитанное значение

**Важно:** Обратите внимание, что название столбцов в вашем ответе должно в точности совпадать с условием.

## Подсказка 1
Решить данную задачу можно несколькими способами: например, через рекурсию или с помощью логарифмов и степеней.

## Подсказка 2
Чтобы решить задачу через логарифмы, нужно воспользоваться двумя правилами:

```
$log10(a)+log10(b)+... = log10(ab...)$
$10^log10(a) = a$
```

Тогда, посчитав сумму десятичных логарифмов элементов таблицы ```Numbers```, а затем возведя число 10 в получившуюся степень, мы можем получить желаемый результат.

У этого решения есть большой недостаток - может накопиться приличная ошибка из-за дробных значений и ответ будет неправильным.

**Примечание:** Если в таблице много элементов или они принимают большие значения, то результат будет очень большим - не забудьте привести его к типу ```bigint```. Сделать это можно с помощью функции ```CAST```.

## Подсказка 3
Второй вариант решения - через рекурсию. Чтобы использовать этот вариант решения, нужно произвести небольшую подготовку:

Сначала пронумеруйте строки с помощью ```ROW_NUMBER```. Эту часть запроса поместите в ```CTE```.
Напишите рекурсивный запрос. В первом блоке просто выберите элемент столбца a (это будет множитель) и ранг из полученной ранее таблицы, где ранг равен единицы. Элемент столбца a сразу приведите к типу ```bigint```, чтобы в дальнейшем результат был этого же типа. Во втором блоке рекурсии (после ```UNION ALL```) множитель из первого блока должен умножаться на следующий элемент, а ранг просто перезаписываться на следующий.
Во вшешнем запросе просто отберите ту строку из получившейся таблицы, где ранг максимален.

## Решение
``` SQL
SELECT ROUND(EXP(SUM(LN(a))))::BIGINT
FROM Numbers
```

## Подход 1
Подход 1 использует основные правила работы с логарифмами. Но является изящным, но не точным, т.к. потенциально может накопиться ошибка:


``` SQL 
SELECT CAST(10^(SUM(LOG10(a))) AS bigint) AS multiplier
FROM numbers
```

## Подход 2
Второе решение использует рекурсивный подход:

``` SQL
WITH recursive A(multiplier, rn) AS
(
SELECT cast(a as bigint) as multiplier,
       rn
FROM B
WHERE rn = 1
UNION ALL
SELECT multiplier * b.a as multiplier,
       B.rn as rn
FROM A
JOIN B
ON A.rn + 1 = B.rn
),
B AS
(
SELECT a,
ROW_NUMBER() OVER (ORDER BY a) AS rn
FROM numbers
)
SELECT multiplier
FROM a
WHERE rn = (SELECT MAX(rn) FROM a)
```